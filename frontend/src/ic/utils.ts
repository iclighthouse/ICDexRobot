import { Principal } from '@dfinity/principal';
import { Identity } from '@dfinity/agent';
import { Ed25519KeyIdentity } from '@dfinity/identity';
import { Secp256k1KeyIdentity } from '@dfinity/identity-secp256k1';
const EC = require('elliptic').ec;
const KeyEncoder = require('key-encoder').default;
const keyEncoder = new KeyEncoder('secp256k1');
// Create and initialize EC context
// (better do it once and reuse it)
const ec = new EC('secp256k1');
const {
  key_new,
  key_to_pub_key,
  seed_from_pem
} = require('@dfinity/rosetta-client');
const pbkdf2 = require('pbkdf2');
const sjcl = require('sjcl');
const encrypt = (
  message: string,
  password: string,
  salt: string,
  keylen = 256,
  digest = 'sha512'
): Promise<string> => {
  let iterations = 100;
  if (process.env.NODE_ENV === 'production') {
    iterations = 210000;
  }
  if (salt === 'ICLightHouse' && process.env.NODE_ENV === 'production') {
    iterations = 10000;
  }
  return new Promise((resolve, reject) => {
    pbkdf2.pbkdf2(
      password,
      salt,
      iterations,
      keylen,
      digest,
      (err: Error | null, derivedKey: Buffer) => {
        if (err) {
          reject(err);
        }
        resolve(sjcl.encrypt(derivedKey.toString(), btoa(message)));
      }
    );
  });
};
const decrypt = (
  data: string,
  password: string,
  salt: string,
  keylen = 256,
  digest = 'sha512'
): Promise<string> => {
  let iterations = 100;
  if (process.env.NODE_ENV === 'production') {
    iterations = 210000;
  }
  if (salt === 'ICLightHouse' && process.env.NODE_ENV === 'production') {
    iterations = 10000;
  }
  return new Promise((resolve, reject) => {
    pbkdf2.pbkdf2(
      password,
      salt,
      iterations,
      keylen,
      digest,
      (err: Error | null, derivedKey: Buffer) => {
        if (err) {
          reject(err);
        }
        try {
          resolve(atob(sjcl.decrypt(derivedKey.toString(), data)));
        } catch (e) {
          reject(e);
        }
      }
    );
  });
};
const isHex = (h: any): boolean => {
  const regexp = /^[0-9a-fA-F]+$/;
  return regexp.test(h);
};
const isHexString = (value: string): boolean => {
  if (value.substr(0, 2) === '0x') {
    value = value.replace(/^0x/i, '');
  }
  return isHex(value);
};
const validateAccount = (a: string): boolean => {
  return isHex(a) && a.length === 64;
};
const validatePrincipal = (principal: string): boolean => {
  try {
    return principal === Principal.fromText(principal).toText();
  } catch (e) {
    return false;
  }
};
const identityFromPem = (rawPrivateKey: string): Identity => {
  if (
    rawPrivateKey.startsWith('-----BEGIN EC PARAMETERS-----') ||
    rawPrivateKey.startsWith('-----BEGIN EC PRIVATE KEY-----')
  ) {
    try {
      // EC secp256k1
      const derPrivateKey = keyEncoder.encodePrivate(
        rawPrivateKey,
        'pem',
        'raw'
      );
      const key = ec.keyFromPrivate(derPrivateKey, 'hex');
      const publicKey = key.getPublic('hex');
      const identity = Secp256k1KeyIdentity.fromJSON(
        JSON.stringify([publicKey, derPrivateKey])
      );
      return identity;
    } catch (e) {
      return null;
    }
  } else {
    try {
      // The PEM file generated by `dfx new`
      // Only supports PEM files generated by dfx at the moment.
      const seed = seed_from_pem(rawPrivateKey);
      const privateKey = key_new(seed);
      const publicKey = key_to_pub_key(privateKey);
      const identity = Ed25519KeyIdentity.fromKeyPair(publicKey, privateKey);
      return identity;
    } catch (e) {
      return null;
    }
  }
};
export {
  isHexString,
  validateAccount,
  validatePrincipal,
  encrypt,
  decrypt,
  identityFromPem
};

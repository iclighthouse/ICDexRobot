import { Identity } from '@dfinity/agent';
import { Ed25519KeyIdentity } from '@dfinity/identity';
import { Secp256k1KeyIdentity } from '@dfinity/identity-secp256k1';
const EC = require('elliptic').ec;
const KeyEncoder = require('key-encoder').default;
const keyEncoder = new KeyEncoder('secp256k1');
// Create and initialize EC context
// (better do it once and reuse it)
const ec = new EC('secp256k1');
const {
  key_new,
  key_to_pub_key,
  seed_from_pem
} = require('@dfinity/rosetta-client');
const SUB_ACCOUNT_BYTE_LENGTH = 32;
// @ts-ignore
const SerializableIC = (x) => {
  if (x === undefined || x === null) return x;
  if (ArrayBuffer.isView(x) || x instanceof ArrayBuffer) {
    // @ts-ignore
    return [...x].map((y) => SerializableIC(y));
  }
  if (Array.isArray(x)) {
    // @ts-ignore
    return x.map((y) => SerializableIC(y));
  }
  if (typeof x === 'object') {
    if (x._isPrincipal) {
      return x;
    }
    return Object.fromEntries(
      // @ts-ignore
      Object.keys(x).map((k) => {
        return [k, SerializableIC(x[k])];
      })
    );
  }
  return x;
};
const fromSubAccountId = (subAccountId: number): Array<number> => {
  const buffer = numberToArrayBuffer(subAccountId, SUB_ACCOUNT_BYTE_LENGTH);
  return arrayBufferToArrayOfNumber(buffer);
};
const arrayBufferToArrayOfNumber = (buffer: ArrayBuffer): Array<number> => {
  const typedArray = new Uint8Array(buffer);
  return Array.from(typedArray);
};
const numberToArrayBuffer = (
  value: number,
  byteLength: number
): ArrayBuffer => {
  const buffer = new ArrayBuffer(byteLength);
  new DataView(buffer).setUint32(byteLength - 4, value);
  return buffer;
};
const toHexString = (bytes: Uint8Array): string => {
  return bytes.reduce(
    (str, byte) => str + byte.toString(16).padStart(2, '0'),
    ''
  );
};
const hexToBytes = (hex: string): number[] => {
  if (hex.substring(0, 2) === '0x') {
    hex = hex.replace(/^0x/i, '');
  }
  const bytes = [];
  for (let c = 0; c < hex.length; c += 2) {
    bytes.push(parseInt(hex.substr(c, 2), 16));
  }
  return bytes;
};
const identityFromPem = (rawPrivateKey: string): Identity | null => {
  if (
    rawPrivateKey.startsWith('-----BEGIN EC PARAMETERS-----') ||
    rawPrivateKey.startsWith('-----BEGIN EC PRIVATE KEY-----')
  ) {
    try {
      // EC secp256k1
      const derPrivateKey = keyEncoder.encodePrivate(
        rawPrivateKey,
        'pem',
        'raw'
      );
      const key = ec.keyFromPrivate(derPrivateKey, 'hex');
      const publicKey = key.getPublic('hex');
      const identity = Secp256k1KeyIdentity.fromJSON(
        JSON.stringify([publicKey, derPrivateKey])
      );
      return identity;
    } catch (e) {
      console.error(e);
      return null;
    }
  } else {
    try {
      // The PEM file generated by `dfx new`
      // Only supports PEM files generated by dfx at the moment.
      const seed = seed_from_pem(rawPrivateKey);
      const privateKey = key_new(seed);
      const publicKey = key_to_pub_key(privateKey);
      const identity = Ed25519KeyIdentity.fromKeyPair(publicKey, privateKey);
      return identity;
    } catch (e) {
      console.error(e);
      return null;
    }
  }
};
export {
  SerializableIC,
  fromSubAccountId,
  toHexString,
  hexToBytes,
  identityFromPem
};
